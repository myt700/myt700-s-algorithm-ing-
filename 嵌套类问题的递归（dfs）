1.请写一个整数计算器，支持加减乘三种运算和括号。
题解：这道题有两个关键：一个是数字不只是一位数，怎么把数字变成几位数；第二个是计算过程，需要用两个栈来存数字和符号
核心思想：1.表达式的顺序如何表示：栈的思想：先进后出：可以用来处理优先级的问题
2.计数怎么计：cur=cur*10+s[i]-'0'，思想就是数学原理我需要在末尾加上一个数，那我就需要把前面的*10，就等于向左移动一位

那如果有了括号呢？我就很难按优先级顺序去除了！但是在括号内：我可以按照原来的顺序执行了！
所以就是一个嵌套！
那怎么样知道自己在哪里返回呢？是不是就要有一个全局变量来告诉嵌套在哪里返回，所以就有了全局变量where
“我到了一个位置，需要开始一个嵌套，我就在那等着嵌套返回我需要的值”
所以刚开始说的东西其实就是我所有嵌套的子过程
那么我刚开始就应该就只写一个大过程，再去实现每个小过程
因为代码不会写，所以我再详细写一下：
总的思路如上所述

代码实现：
class Solution{
pubic:
  int compute(const vector<int> &num,const vecotr<char> &op){
    int n = num.size();
    int ans = num[0];
    for(int i=1;i<n;i++){
      ans+=ops[i-1]=='+' ? num[i] : -num[i];
  }
  return ans;
  }
  void push(vector<int> &num,vector<char> &op,int cur,char op){
    int n = num.size();
    if(n == 0 || op[n-1]=='+'||op[n-1]=='-'){
      num.push_back(cur);
      op.push_back(op);
    }else{
      int top = num[n-1];
      chart topop = op[n-1];
      if(topop == '*'){
        num[n-1] == top * cur;
      }else{
        num[n-1] = top / cur;
      }
      op[n-1] = op;
    }
  }
  int f(const string& s,int i){
    int cur = 0;
    vector<int> num;
    vectort<char> op;
    while(i<s.size() && s[i]!= ")"){
      if(s[i]>='0'&&s[i] <= '9'){
        cur+=cur*10+s[i]-'0';
      }else if(s[i]!='('){
        push(num,op,cur,s[i]);i++;
        cur=0;
      }else{
        f(s,i+1);
        i=where+1;
      }
    }
    push(num,op,cur,'+');
    where = i;
    return compute(num,op);
  }
反正核心思路就是这样，后面我就懒得写了
要是代码写成这样，那我就想写了哈哈哈：
int f(const string& s,int& idx) {
    vector<int> nums;
    char op = '+';
    int num = 0;
    while (idx < s.size() && s[idx]!=')') {
        char c = s[idx];idx++;
        if (isdigit(c)) {
            num = num*10+(c-'0');
        }else if (c == '(') {
            num = f(s,idx);
        }else {
            if (op == '+') nums.push_back(num);
            else if (op == '-') nums.push_back(-num);
            else if (op == '*') nums.back() *= num;
            else if (op == '/') nums.back() /= num;
            op = c;
            num = 0;
        }
    }
}
下播！
嵌套类问题的解题思路：
1.定义全局变量：where
2.递归函数f(i)：从i位置出发，遇到题目隐含终止条件或嵌套终止条件就返回
3.返回值f（i）就是这一段的结果
4.f（i）返回前要更新全局where的结果，让上级函数知道where解析到什么位置

接下来这个题也是一样的，其实我主要是代码不会写，代码不会写的核心是思路不清楚
接下来我将写一个思路非常清晰的题解
题目：给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
首先整体思路还是我只管我的括号的返回值，遇到了新括号，我就停在那里，等它的返回值
那么：我需要一个函数：来记录这一段的字符，然后还有一个函数，来具体实现细节
记录这一段字符的函数的思路是：在没有遇到[之前，我先把这些东西存起来，存起来的思路其实跟上面一样，遇到以后，我先把这些加到我的字符里面去
那我怎么知道到哪里结束呢，就是用where来记录
然后你还要确保你的每次操作要更新where，那么怎么更新where呢？我们就可以在所有搜集的结束后来到位置i
那么where=i就可以了，同时这道题要求你最终返回的是字符串，所以你要注意一下最后的返回
还是C++好哈哈哈，写起来比java简单多了、
string decode(const string& s,int& idx) {
    string res;int cnt=0;
    while (idx<s.size() && s[idx] != ']') {
        if (isalpha(s[idx])) {
            res.push_back(s[idx]);idx++;
        }else if (isdigit(s[idx])) {
            cnt = cnt*10 + (s[idx] - '0');
        }else {
            idx++;
            string in = decode(s,idx);
            idx++;
            for (int i=0;i<cnt;i++) res+=in;
            cnt=0;
        }
    }
}
