建图一直不会，今天一定要学会！
代码如下：
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

// 点的最大数量
const int MAXN = 11;

// 边的最大数量
// 只有链式前向星方式建图需要这个数量
// 注意如果无向图的最大数量是m条边，数量要准备m*2
// 因为一条无向边要加两条有向边
const int MAXM = 21;

// 邻接矩阵方式建图
int graph1[MAXN][MAXN];

// 邻接表方式建图
vector<vector<pair<int, int>>> graph2;

// 链式前向星方式建图
int head[MAXN];
int next_[MAXM];  // 避免与标准库的next冲突
int to[MAXM];
int weight[MAXM];
int cnt;

void build(int n) {
    // 邻接矩阵清空
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            graph1[i][j] = 0;
        }
    }
    
    // 邻接表清空和准备
    graph2.clear();
    // 下标需要支持1~n，所以加入n+1个列表，0下标准备但不用
    for (int i = 0; i <= n; i++) {
        graph2.push_back(vector<pair<int, int>>());
    }
    
    // 链式前向星清空
    cnt = 1;
    memset(head + 1, 0, n * sizeof(int));
}

// 链式前向星加边
void addEdge(int u, int v, int w) {
    // u -> v , 边权重是w
    next_[cnt] = head[u];
    to[cnt] = v;
    weight[cnt] = w;
    head[u] = cnt++;
}

// 三种方式建立有向图带权图
void directGraph(vector<vector<int>>& edges) {
    // 邻接矩阵建图
    for (auto& edge : edges) {
        graph1[edge[0]][edge[1]] = edge[2];
    }
    
    // 邻接表建图
    for (auto& edge : edges) {
        graph2[edge[0]].push_back({edge[1], edge[2]});
    }
    
    // 链式前向星建图
    for (auto& edge : edges) {
        addEdge(edge[0], edge[1], edge[2]);
    }
}

// 三种方式建立无向图带权图
void undirectGraph(vector<vector<int>>& edges) {
    // 邻接矩阵建图
    for (auto& edge : edges) {
        graph1[edge[0]][edge[1]] = edge[2];
        graph1[edge[1]][edge[0]] = edge[2];
    }
    
    // 邻接表建图
    for (auto& edge : edges) {
        graph2[edge[0]].push_back({edge[1], edge[2]});
        graph2[edge[1]].push_back({edge[0], edge[2]});
    }
    
    // 链式前向星建图
    for (auto& edge : edges) {
        addEdge(edge[0], edge[1], edge[2]);
        addEdge(edge[1], edge[0], edge[2]);
    }
}

void traversal(int n) {
    cout << "邻接矩阵遍历 :" << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << graph1[i][j] << " ";
        }
        cout << endl;
    }
    
    cout << "邻接表遍历 :" << endl;
    for (int i = 1; i <= n; i++) {
        cout << i << "(邻居、边权) : ";
        for (auto& edge : graph2[i]) {
            cout << "(" << edge.first << "," << edge.second << ") ";
        }
        cout << endl;
    }
    
    cout << "链式前向星 :" << endl;
    for (int i = 1; i <= n; i++) {
        cout << i << "(邻居、边权) : ";
        // 注意这个for循环，链式前向星的方式遍历
        for (int ei = head[i]; ei > 0; ei = next_[ei]) {
            cout << "(" << to[ei] << "," << weight[ei] << ") ";
        }
        cout << endl;
    }
}

int main() {
    // 理解了带权图的建立过程，也就理解了不带权图
    // 点的编号为1...n
    // 例子1自己画一下图，有向带权图，然后打印结果
    int n1 = 4;
    vector<vector<int>> edges1 = {
        {1, 3, 6}, {4, 3, 4}, {2, 4, 2}, 
        {1, 2, 7}, {2, 3, 5}, {3, 1, 1}
    };
    build(n1);
    directGraph(edges1);
    traversal(n1);
    
    cout << "==============================" << endl;
    
    // 例子2自己画一下图，无向带权图，然后打印结果
    int n2 = 5;
    vector<vector<int>> edges2 = {
        {3, 5, 4}, {4, 1, 1}, {3, 4, 2}, 
        {5, 2, 4}, {2, 3, 7}, {1, 5, 5}, {4, 2, 6}
    };
    build(n2);
    undirectGraph(edges2);
    traversal(n2);
    
    return 0;
}
算法书中的建图：
//邻接表
struct edge{
    int from,to,w;
    edge(int a,int b,int c){
        from=a;to=b;w=c//对边赋值
    }
};
vector<edge>e[N];//e[i]:储存第i个节点连接的所有边
//初始化
for(int i=1;i<=n;i++){
    e[i].clear();
}
//存边
e[a].push_back(edge(a,b,c));//把边（a，b）存到节点a的邻接表中
//遍历节点u的所有邻居
for(int i=0;i<e[u].size();i++){
    int 
//新写的详细版链式前向星
#include<iostream>
#include<vector>
using namespace std;
//head[0 0 0 0]头边号：如果是0则没有边了
//     0 1 2 3 点号
//next[       ]下一条边号
//              边号
//to  [       ]去往的点
//              边号
//1->3 一号边 cnt++
//4->3 二号边 cnt++
//2->4 三号边 cnt++
//1->2 四号边 cnt++
//1->4 五号边 cnt++
//head[0 5 3 0 2]头边号：如果是0则没有边了
//     0 1 2 3 4 点号
//next[  0 0 0 1 4]下一条边号
//       1 2 3 4 5 边号
//to  [  3 3 4 2 4]去往的点
//       1 2 3 4 5 边号
//1号->5号->4号->1号->0号
//weight[      ]权重
//              编号
int maxn=11;//点的最大数量
int maxm=22;//无向图边的数量是点的两倍
//建图
int head[maxn];
int next[maxm],to[maxm],weight[maxm];
int cnt;//边号
void addEdge(int u,int v,int w){
	next[cnt]=head[u];//现在的边的下一条边是老头部
	to[cnt]=v;//现在这一条边去往v点
	weight[cnt]=w;//现在这一条边的权重是w
	head[u]=cnt++;//u点头部的边就是cnt，然后让cnt++
}
int main()
{
	//链式前向星清空
	cnt=1;
	memset(head,0,sizeof(head));
	for(int i=1;i<=n;i++){
		for(int ei=head[i];ei>0;ei=next[ei]){
			cout<<to[ei]<<" "<<weight[ei]<<endl;
		}
	}
}
